// console3.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>

using namespace std;

#pragma region 연산자 + 반복문

/*
연산자란?
-- 프로그램이 동작할때 정해져 있는 특정 역할을 수행하는 키워드
ㄴ 연산자를 이용하면 다양한 프로그램 로직을 만들어내는 것이 가능하다.


- 산술 연산자** (+,-,*,/,$)
- 비교 연산자** ( ==, !=,<,>,<=,>=)

 num == num2;   num과 num2가 같다.
 
 num != num2;   num과 num2가 같지 않다.

 num < num2;    num가 num2보다 작다

 num > num2;   num이 num2보다 크다

 num<= num2;   num이 num2보다 작거나 같다.

 num >= num2;  num이 num2보다 크거나 같다.


- 할당 연산자** ( =, +=, -=,*=,/=,%=) 결합방향: 우>좌

+= 
-=
*=
/=
%= 



- 비트 연산자 (&,|,^) - 패스 플레이어 상태값/ 색상값 검출 사용 (디버프) ex) 독, 출혈, 경직
- 효율적 메모리 사용과 빠른 연산이 장점

& 
|
^
~
<<

>>


- 논리 연산자** (&&,||,!)


*** 면접질문 ***
- 형변환 연산자 ex) rand_MAX > (int)32767  ((특정 자료형)
  ㄴ ((특정 자료형)) 변수형
  ㄴ int value = 0;
  ㄴ (float)Value;

  c언어 형변환은 강제 형변환: 논리 보다는 명령우선. 강제로 바꾸기 때문에 리스크가 크다.
  다른 안전한 형변환에 비해 속도가 빠르기 때문에 확신이 있으면 강제 형변환이 좋긴 함.

  ** 강제 형변환에 대하여..
  ㄴ C스타일의 명시적 형변환은 기본적으로 가독성이 떨어지고 버그가 생길 여지가 다분하다.
  ㄴ '강제'로 형을 바꾸어주기 때문.
  ㄴ 속도를 챙길것이면 C스타일로/ 안정성을 챙길것이면 C++스타일로 변환하면된다.

  EX:
  static_cast<int>(obj) -> obj를 type으로 바꾸겠다.
  단. 논리접으로 가능한 경우에만 변환 수행. -> 안정성 up

  ㄴ c++ 타입 캐스팅 연산자 시리즈** (명시적)
  static_cast 
  dynamic_cast
  const_cast
  reinterpret_cast

  cpu 우선 연산순위에서 밀린다
  float > int 할떄 소숫점 아래 버려짐.
  

  c/c++ 언어는 형변환 연산자를 이용하면 간단하게 해당 변수의 자료형을 변경하는 것이 가능하다.



 반복문이란?
 - 프로그램의 특정 부분을 일정 횟수 이상 반복해서 실행하도록 하기 위한 문법.
 ㄴ 반복문을 이용하면 반복적으로 발생되는 구간을 효율적/간단하게 처리하는 것이 가능하다.
 ㄴ 문법을 잘 활용하면 편리함과 효율성이 수직 상승한다.
 
1. for문 
- 구성

ㄴ 초기식: 반복을 위한 변수의 선언 및 초기화 수행
ㄴ 조건식: 반복의 조건을 검사하는 목적으로 선언
ㄴ 증감식: 반복의 조건을 거짓으로 만드는 증가 및 감소

ex) for ( 초기식: 조건식: 증감식)
{
 반복이 되는 문장
}
* 초기값은 맨 처음에 한번만 수행이 되고 조건식이 참인 동안만 명령문을 반복 수행한다.
  몇번 반복하는지를 확실하게 알고 있다면 for문이 제일 간결하게 코드가 적힌다. 

2. while문 
* 무한(loop): 반복 조건에 1(참)이 들어갈 경우 무한 루프에 빠지게 된다.
  ㄴ 조건이 true(참)일때만 작동
  ㄴ 후에 배울 제어문으로 빠져나올 수 있다.
  -while 문은 특정 조건을 주고 그 조건을 만족하는 동안 특정 영역을 계속해서 반복하는 구죠.
  * 반복의 조건을 거짓으로 만드는게 가장중요( 계속 참이면 무한루프가 돌기 때문)
  
3. do while문 
    *  while문과의 차이점: 조건을 검사하는 시점이 다르다.
    * 일단 무조건 한번 실행 후, while문의 조건을 검사하여 do while문 안의 문장을 실행할 것인지에 대해 판단한다.
    


반복문 부터는 논리사고에 따라 실행시간 차이가 확연히 드러난다. 쓰는건 쉽지만 (잘)쓰는게 어려움.
많이 써보는게 좋음.


*/

int main()
{/*
    int numberA = 0;
    numberA = 1;
    numberA ++;
    numberA = 6;
    numberA ++;
    numberA += 5;
    numberA --;
    numberA -=2;
    numberA *=3;
    numberA /=2;
    

    cout << "numberA의 값:" << numberA << endl;


    int i;  // C스타일 > 컴파일러 버전에 따라 유동적

    for (i = 0; i < 10; i++)
    {
        cout << "[" << i << "번째]" << "공부하고 인내하면 너희도 개발자" << endl;
    }

    int numberB = 0;
    for (; numberB < 5; numberB++)
    {
        cout << " 이렇게 사용을 하면?" << endl;
        //for문은 식을 생략이 다 가능하다(초기식,조건식,증감식)
    }
    printf("\n");

    int j = 1;
    for (int i = 0; i < 5; i++)
    {
        cout << "첫번째 값은?" << ++j << endl;
        cout << " 두번째 값은?" << j++ << endl;
           
       
        
    }
    //1234
    cout << '\n';
    cout << "\n";
    printf("\n");
    cout << endl;

    for문안에 for문을 사용하는 이중 for문도 있다.

    */

    for (int i = 1; i <= 10; i++)
    {
        cout << i << endl;
    }
    for (int i = 1; i <= 10; i++)
    {
        cout << 11 - i << endl;
    }

    for (int j = 1; j <= 9; j++)
    {
        

        for (int i = 2; i <= 4; i++)
        {
            cout << i << "X" << j << "=" << i * j << "\t";
        }
        cout << endl;

        
    }
    cout << endl << endl;
    for (int j = 1; j <= 9; j++)
    {


        for (int i = 5; i <= 7; i++)
        {
            cout << i << "X" << j << "=" << i * j << "\t";
        }
        cout << endl;


    }
    cout << endl << endl;

    for (int j = 1; j <= 9; j++)
    {


        for (int i = 7; i <= 8; i++)
        {
            cout << i << "X" << j << "=" << i * j << "\t";
        }
        cout << endl;


    }
}
/*
 C/C++ 언어는 연산자를 이용해서 결과를 만들어낼 때 해당 연산자에 사용된 변수의 자료형에 따라서 결과가 달라진다.
 정수 + 정수  > 정수
 정수 + 실수  > 실수

 기본적으로 연산자를 사용할때는 동일한 자료형의 변수를 가지고 연산을 하는것이 원칙이다.
 하지만 서로 자료형이 다를 경우 연산자에 의한 데이터의 결과는 값을 소실 할 수 있는 위험이 적은 
 자료형으로 만들어진다.

 단, 나머지 연산자(/)는 정수형 데이터에만 사용하는 것이 가능하다.

 for문은 필요에 따라 초기식,조건식,증감식 생략이 가능하다.
 생략 유형
 1. 초기식 생략 -> (;i<10; i++)
  초기 엔트리에 따라 i값이 달라지기 때문에, 초기식을 생략하는 경우가 있다
 2. 조건식 생략  (i=1;; i++)
 3. 증감식 생략  (;i<10; )
 4. 모두 생략   (;; )

 ++i ; 전위 중요  만나는 순간 바로 바뀜
 i++ ; 후위 중요  개행이 되고 바뀜


 endl;<< 공백 뒤까지 확인한후 개행
 \n << 확인 없이 바로 개행

 printf<< 가변함수 ( ) 안의값이 하나여든 몇개이든 다 받아줌 결국은 함수임 ㅇㅇ; 그래서 좀 cout 보다 느림 
*/
// 프로그램 실행: <Ctrl+F5> 또는 [디버그] > [디버깅하지 않고 시작] 메뉴
// 프로그램 디버그: <F5> 키 또는 [디버그] > [디버깅 시작] 메뉴

// 시작을 위한 팁: 
//   1. [솔루션 탐색기] 창을 사용하여 파일을 추가/관리합니다.
//   2. [팀 탐색기] 창을 사용하여 소스 제어에 연결합니다.
//   3. [출력] 창을 사용하여 빌드 출력 및 기타 메시지를 확인합니다.
//   4. [오류 목록] 창을 사용하여 오류를 봅니다.
//   5. [프로젝트] > [새 항목 추가]로 이동하여 새 코드 파일을 만들거나, [프로젝트] > [기존 항목 추가]로 이동하여 기존 코드 파일을 프로젝트에 추가합니다.
//   6. 나중에 이 프로젝트를 다시 열려면 [파일] > [열기] > [프로젝트]로 이동하고 .sln 파일을 선택합니다.
